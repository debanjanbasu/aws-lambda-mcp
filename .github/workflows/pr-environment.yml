name: ðŸŒ± Ephemeral PR Environment

on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
      - closed
    paths-ignore:
      - '**.md'
      - '.gitignore'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - destroy

env:
  AWS_REGION: ap-southeast-2
  CARGO_TERM_COLOR: always

jobs:
  build-lambda:
    name: ðŸ§± Build Lambda
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.pull_request.draft == false && github.event.action != 'closed')
    runs-on: ubuntu-24.04-arm
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Check if Rust files changed
        id: rust_changes
        run: |
          # Check if any Rust-related files have changed
          # We compare against the base branch (main) to detect changes
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For pull requests, check what files changed in the PR
            git fetch origin main:main
            # Handle case where there's no merge base
            if CHANGED_FILES=$(git diff --name-only main...HEAD 2>/dev/null); then
              echo "Using three-dot diff"
            else
              echo "Fallback to two-dot diff"
              CHANGED_FILES=$(git diff --name-only main..HEAD)
            fi
          else
            # For workflow_dispatch, check last commit
            CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD)
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check if any Rust-related files changed
          RUST_CHANGED=false
          while read -r file; do
            if [[ "$file" == src/* ]] || [[ "$file" == *.rs ]] || [[ "$file" == Cargo.toml ]] || [[ "$file" == Cargo.lock ]] || [[ "$file" == Makefile ]] || [[ "$file" == .cargo/* ]]; then
              RUST_CHANGED=true
              echo "Rust-related file changed: $file"
              break
            fi
          done <<< "$CHANGED_FILES"
          
          # If no files changed at all (shouldn't happen), assume no change needed
          if [ -z "$CHANGED_FILES" ]; then
            RUST_CHANGED=false
          fi
          
          echo "rust_changed=$RUST_CHANGED" >> $GITHUB_OUTPUT
          echo "Rust files changed: $RUST_CHANGED"

      - name: Cache Lambda build artifacts
        uses: actions/cache@v4
        with:
          path: |
            target/lambda/
            tool_schema.json
          key: ${{ runner.os }}-${{ runner.arch }}-lambda-build-${{ hashFiles('src/**', 'Cargo.toml', 'Cargo.lock', 'Makefile', '.cargo/**') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-lambda-build-

      - name: Setup Rust toolchain
        id: rust-toolchain
        if: steps.rust_changes.outputs.rust_changed == 'true'
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: rust-src
          targets: aarch64-unknown-linux-gnu

      - name: Cache Rust dependencies
        if: steps.rust_changes.outputs.rust_changed == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-${{ runner.arch }}-cargo-${{ steps.rust-toolchain.outputs.rustc_hash }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-${{ steps.rust-toolchain.outputs.rustc_hash }}-

      - name: Cache cargo-lambda
        if: steps.rust_changes.outputs.rust_changed == 'true'
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/cargo-lambda
          key: ${{ runner.os }}-${{ runner.arch }}-cargo-lambda-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-lambda-

      - name: Install cargo-lambda
        if: steps.rust_changes.outputs.rust_changed == 'true'
        run: |
          if ! command -v cargo-lambda &> /dev/null
          then
            cargo install cargo-lambda
          fi

      - name: Setup Zig
        if: steps.rust_changes.outputs.rust_changed == 'true'
        uses: mlugg/setup-zig@v2
        with:
          version: latest

      - name: Install UPX (for release build compression)
        if: steps.rust_changes.outputs.rust_changed == 'true'
        run: sudo apt-get update && sudo apt-get install -y upx-ucl

      - name: Build Lambda (Release)
        if: steps.rust_changes.outputs.rust_changed == 'true'
        run: make release

      - name: Verify Lambda artifacts exist
        run: |
          # Check if artifacts exist (either from build or cache)
          if [ ! -f "target/lambda/aws-lambda-mcp/bootstrap" ] || [ ! -f "tool_schema.json" ]; then
            echo "ERROR: Required Lambda artifacts not found!"
            ls -la target/lambda/aws-lambda-mcp/ 2>/dev/null || echo "Directory not found"
            ls -la tool_schema.json 2>/dev/null || echo "tool_schema.json not found"
            exit 1
          fi
          echo "Lambda artifacts verified successfully"

      - name: Upload Lambda build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pr-lambda-build
          path: |
            target/lambda/
            tool_schema.json

  deploy-environment:
    name: ðŸŒ Deploy Environment
    needs: build-lambda
    if: always() && (github.event_name == 'workflow_dispatch' || github.event_name == 'pull_request')
    runs-on: ubuntu-slim
    permissions:
      id-token: write
      contents: read
      pull-requests: write

    steps:
      - name: ðŸ“¦ Checkout code
        uses: actions/checkout@v5

      - name: âš™ï¸ Set environment variables
        run: |
          # Set environment name based on PR number or run number
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "ENVIRONMENT_NAME=pr-${{ github.event.number }}" >> $GITHUB_ENV
            echo "PR_NUMBER=${{ github.event.number }}" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT_NAME=manual-${{ github.run_number }}" >> $GITHUB_ENV
            echo "PR_NUMBER=manual" >> $GITHUB_ENV
          fi

      - name: ðŸŽ¯ Determine action
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            if [ "${{ github.event.action }}" = "closed" ]; then
              echo "ACTION=destroy" >> $GITHUB_ENV
            else
              echo "ACTION=deploy" >> $GITHUB_ENV
            fi
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "ACTION=${{ github.event.inputs.action }}" >> $GITHUB_ENV
          fi

      - name: â˜ï¸ Download Lambda build artifacts
        if: env.ACTION == 'deploy' && needs.build-lambda.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: pr-lambda-build
          path: .

      - name: âš™ï¸ Prepare environment-specific variables
        run: |
           # Create environment-specific tfvars file
           echo "project_name = \"aws-agentcore-gateway-pr-${{ env.ENVIRONMENT_NAME }}\"" > iac/pr-environment.tfvars
           echo "common_tags = {" >> iac/pr-environment.tfvars
           echo "  Project     = \"aws-agentcore-gateway\"" >> iac/pr-environment.tfvars
           echo "  ManagedBy   = \"terraform\"" >> iac/pr-environment.tfvars
           echo "  Environment = \"ephemeral-${{ env.ENVIRONMENT_NAME }}\"" >> iac/pr-environment.tfvars
           if [ "${{ env.PR_NUMBER }}" != "manual" ]; then
             echo "  PR_Number   = \"${{ env.PR_NUMBER }}\"" >> iac/pr-environment.tfvars
             echo "  Branch      = \"${{ github.head_ref }}\"" >> iac/pr-environment.tfvars
           else
             echo "  Trigger     = \"manual\"" >> iac/pr-environment.tfvars
             echo "  Run_Number  = \"${{ github.run_number }}\"" >> iac/pr-environment.tfvars
           fi
           echo "}" >> iac/pr-environment.tfvars

           # Update backend key to be environment-specific
            echo "bucket         = \"${{ secrets.TF_BACKEND_BUCKET }}\"" > iac/backend-pr.tfvars
            echo "key            = \"aws-lambda-mcp/${{ env.ENVIRONMENT_NAME }}/terraform.tfstate\"" >> iac/backend-pr.tfvars
            echo "region         = \"${{ env.AWS_REGION }}\"" >> iac/backend-pr.tfvars
            echo "use_lockfile   = true" >> iac/backend-pr.tfvars


      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      - name: ðŸ” Setup Azure CLI
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          allow-no-subscriptions: true

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ðŸ’¾ Cache Terraform plugins
        uses: actions/cache@v4
        with:
          path: iac/.terraform
          key: ${{ runner.os }}-${{ runner.arch }}-terraform-${{ hashFiles('**/iac/.terraform.lock.hcl') }}

      - name: ðŸš€ Terraform Init (Environment)
        if: env.ACTION == 'deploy'
        run: |
          cd iac
          terraform init -backend-config=backend-pr.tfvars

      - name: ðŸš€ Terraform Apply (Environment)
        if: env.ACTION == 'deploy'
        run: |
          cd iac
          terraform apply -auto-approve -var-file=pr-environment.tfvars

      - name: ðŸ’¬ Post Deployment Comment
        if: env.ACTION == 'deploy'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd iac
          GATEWAY_URL=$(terraform output -raw agentcore_gateway_url 2>/dev/null || echo "unavailable")
          if [ "$GATEWAY_URL" != "unavailable" ]; then
            if [ "${{ env.PR_NUMBER }}" != "manual" ]; then
              COMMENT="## ðŸŒ± Ephemeral Environment Deployed

              Your PR environment has been deployed successfully!

              ðŸ”— **Gateway URL**: $GATEWAY_URL

              ðŸ§ª **Testing Instructions**:
              1. Run \`make test-token\` to generate an OAuth token
              2. Launch the MCP Inspector: \`npx @modelcontextprotocol/inspector --transport http --server-url \"$GATEWAY_URL\"\`
              3. Use the token to authenticate in the Inspector UI

              ðŸ“‹ **Environment Details**:
              - Environment: \`${{ env.ENVIRONMENT_NAME }}\`
              - Branch: \`${{ github.head_ref }}\`

              â„¹ï¸ This environment will be automatically destroyed when the PR is closed or merged."
            else
              COMMENT="## ðŸŒ± Manual Environment Deployed

              Your manual environment has been deployed successfully!

              ðŸ”— **Gateway URL**: $GATEWAY_URL

              ðŸ§ª **Testing Instructions**:
              1. Run \`make test-token\` to generate an OAuth token
              2. Launch the MCP Inspector: \`npx @modelcontextprotocol/inspector --transport http --server-url \"$GATEWAY_URL\"\`
              3. Use the token to authenticate in the Inspector UI

              ðŸ“‹ **Environment Details**:
              - Environment: \`${{ env.ENVIRONMENT_NAME }}\`
              - Run Number: \`${{ github.run_number }}\`

              âš ï¸ **Manual Cleanup Required**: Destroy this environment manually when no longer needed:
              \`\`\`
              gh workflow run pr-environment.yml -f action=destroy
              \`\`\`"
            fi
          else
            if [ "${{ env.PR_NUMBER }}" != "manual" ]; then
              COMMENT="## ðŸŒ± Ephemeral Environment Deployment Started
            
              Your PR environment deployment has started. Please wait for completion.
            
              This comment will be updated once the deployment is complete."
            else
              COMMENT="## ðŸŒ± Manual Environment Deployment Started
            
              Your manual environment deployment has started. Please wait for completion.
            
              This comment will be updated once the deployment is complete."
            fi
          fi
          
          if [ "${{ env.PR_NUMBER }}" != "manual" ]; then
            # For PRs, add/update comment on the PR
            gh api repos/${{ github.repository }}/issues/${{ env.PR_NUMBER }}/comments -f body="$COMMENT" >/dev/null 2>&1 || true
          fi

      - name: ðŸ’¬ Update Comment with Final Details
        if: env.ACTION == 'deploy' && success()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd iac
          GATEWAY_URL=$(terraform output -raw agentcore_gateway_url 2>/dev/null || echo "unavailable")
          if [ "$GATEWAY_URL" != "unavailable" ]; then
            if [ "${{ env.PR_NUMBER }}" != "manual" ]; then
              COMMENT="## ðŸŒ± Ephemeral Environment Deployed âœ…

              Your PR environment has been deployed successfully!

              ðŸ”— **Gateway URL**: $GATEWAY_URL

              ðŸ§ª **Testing Instructions**:
              1. Run \`make test-token\` to generate an OAuth token
              2. Launch the MCP Inspector: \`npx @modelcontextprotocol/inspector --transport http --server-url \"$GATEWAY_URL\"\`
              3. Use the token to authenticate in the Inspector UI

              ðŸ“‹ **Environment Details**:
              - Environment: \`${{ env.ENVIRONMENT_NAME }}\`
              - Branch: \`${{ github.head_ref }}\`

              â„¹ï¸ This environment will be automatically destroyed when the PR is closed or merged."
            else
              COMMENT="## ðŸŒ± Manual Environment Deployed âœ…

              Your manual environment has been deployed successfully!

              ðŸ”— **Gateway URL**: $GATEWAY_URL

              ðŸ§ª **Testing Instructions**:
              1. Run \`make test-token\` to generate an OAuth token
              2. Launch the MCP Inspector: \`npx @modelcontextprotocol/inspector --transport http --server-url \"$GATEWAY_URL\"\`
              3. Use the token to authenticate in the Inspector UI

              ðŸ“‹ **Environment Details**:
              - Environment: \`${{ env.ENVIRONMENT_NAME }}\`
              - Run Number: \`${{ github.run_number }}\`

              âš ï¸ **Manual Cleanup Required**: Destroy this environment manually when no longer needed:
              \`\`\`
              gh workflow run pr-environment.yml -f action=destroy
              \`\`\`"
            fi
            
            if [ "${{ env.PR_NUMBER }}" != "manual" ]; then
              # For PRs, update the comment on the PR
              gh api repos/${{ github.repository }}/issues/${{ env.PR_NUMBER }}/comments -f body="$COMMENT" >/dev/null 2>&1 || true
            fi
          fi

      - name: ðŸ’£ Terraform Destroy (Environment)
        if: env.ACTION == 'destroy'
        run: |
          cd iac
          # Create a dummy Lambda binary for validation during destroy
          mkdir -p ../target/lambda/aws-lambda-mcp
          echo "dummy-content-for-destroy-operations" > ../target/lambda/aws-lambda-mcp/bootstrap
          # Initialize Terraform with backend config (without reconfigure to avoid validation)
          terraform init -backend-config=backend-pr.tfvars
          # Destroy infrastructure
          terraform destroy -auto-approve -var-file=pr-environment.tfvars

      - name: ðŸ§¹ Cleanup Terraform State File
        if: env.ACTION == 'destroy'
        run: |
          # Remove the state file from S3 to prevent accumulation
          STATE_KEY="aws-lambda-mcp/${{ env.ENVIRONMENT_NAME }}/terraform.tfstate"
          echo "Cleaning up Terraform state file: s3://${{ secrets.TF_BACKEND_BUCKET }}/$STATE_KEY"
          aws s3 rm "s3://${{ secrets.TF_BACKEND_BUCKET }}/$STATE_KEY" || echo "State file cleanup may have failed, continuing..."

      - name: ðŸ’¬ Notify Environment Destruction
        if: env.ACTION == 'destroy'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ env.PR_NUMBER }}" != "manual" ]; then
            COMMENT="## ðŸŒ± Ephemeral Environment Destroyed ðŸ—‘ï¸
          
            Your PR environment has been successfully destroyed.
          
            ðŸ“‹ **Details**:
            - Environment: \`${{ env.ENVIRONMENT_NAME }}\`
            - Branch: \`${{ github.head_ref }}\`
          
            âœ… All resources have been cleaned up."
          
            # Add a final comment to the PR
            gh api repos/${{ github.repository }}/issues/${{ env.PR_NUMBER }}/comments -f body="$COMMENT" >/dev/null 2>&1 || true
          fi