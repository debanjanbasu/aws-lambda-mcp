name: ðŸ¥· Brown Ninja Bot - Coding Copilot
on:
  issues:
    types: [opened]
  workflow_run:
    workflows: ["*"]
    types: [completed]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to fix'
        required: false
        type: string
concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.number || github.event.inputs.issue_number || github.run_id }}
  cancel-in-progress: true
jobs:
  fix:
    name: ðŸ¤– Analyze, Fix & PR
    if: |
      github.event_name == 'issues' ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'failure' &&
       github.event.workflow_run.actor.login != 'brown-ninja-bot[bot]')
    runs-on: ubuntu-24.04-arm
    permissions:
      id-token: write
      contents: write
      pull-requests: write
      issues: write
    env:
      AWS_REGION: ap-southeast-2
      CARGO_TERM_COLOR: always
    steps:
      - name: ðŸ”‘ Generate Token
        id: generate_token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
      - name: ðŸ“¦ Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: ðŸ”§ Setup Git
        run: |
          git config user.name "brown-ninja-bot[bot]"
          git config user.email "brown-ninja-bot[bot]@users.noreply.github.com"
      - name: ðŸš€ Notify Working
        run: |
          if [ "${{ github.event_name }}" = "issues" ]; then
            ISSUE_NUM=${{ github.event.issue.number }}
            MESSAGES=(
              "ðŸ¥· Brown Ninja Bot activated! Sneaking through the codebase shadows to eliminate this issue..."
              "ðŸ¥· *poof* Brown Ninja Bot vanishes into the code! Reappearing with a fix soon..."
              "ðŸ¥· Ninja mode engaged! Disappearing into the codebase to fix this issue..."
              "ðŸ¥· Brown Ninja Bot: 'A fix in the shadows is worth two in the light!' Analyzing now..."
              "ðŸ¥· Stealth mode initiated! Brown Ninja Bot is hunting down this issue..."
            )
            RANDOM_MESSAGE="${MESSAGES[$RANDOM % ${#MESSAGES[@]}]}"
            gh issue comment $ISSUE_NUM --body "$RANDOM_MESSAGE Setting up my ninja tools..."
          fi
      - name: ðŸ¦€ Setup Rust
        id: rust-toolchain
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: rust-src, clippy, rustfmt
          targets: aarch64-unknown-linux-gnu
      - name: ðŸ’¾ Cache Rust dependencies
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-${{ runner.arch }}-cargo-${{ steps.rust-toolchain.outputs.rustc_hash }}-${{ hashFiles('**/Cargo.lock', '**/Cargo.toml', 'rust-toolchain.toml') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-cargo-${{ steps.rust-toolchain.outputs.rustc_hash }}-
            ${{ runner.os }}-${{ runner.arch }}-cargo-
      - name: ðŸ’¾ Cache cargo-lambda
        uses: actions/cache@v5
        with:
          path: ~/.cargo/bin/cargo-lambda
          key: ${{ runner.os }}-${{ runner.arch }}-cargo-lambda-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-lambda-
      - name: ðŸ”§ Install cargo-lambda
        run: |
          if ! command -v cargo-lambda &> /dev/null
          then
            cargo install cargo-lambda
          fi
      - name: ðŸ”§ Setup Zig
        uses: mlugg/setup-zig@v2
        with:
          version: latest
      - name: ðŸ“¦ Get Latest UPX Version
        id: get-upx-version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "â¬‡ï¸ Finding latest UPX release..."
          # Get the latest release tag from GitHub API with authentication
          LATEST_TAG=$(curl -s -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/upx/upx/releases/latest | jq -r .tag_name)
          # Fallback to known stable version if API fails
          if [ "$LATEST_TAG" == "null" ] || [ -z "$LATEST_TAG" ]; then
            echo "âš ï¸ Failed to fetch latest version. Falling back to v5.0.2"
            LATEST_TAG="v5.0.2"
          fi
          VERSION=${LATEST_TAG#v} # Remove 'v' prefix
          echo "ðŸš€ Latest version: $LATEST_TAG ($VERSION)"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      - name: ðŸ’¾ Cache UPX
        id: cache-upx
        uses: actions/cache@v5
        with:
          path: ~/.local/bin/upx
          key: ${{ runner.os }}-${{ runner.arch }}-upx-${{ steps.get-upx-version.outputs.version }}
      - name: ðŸ“¦ Install UPX (Latest Release)
        if: steps.cache-upx.outputs.cache-hit != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.get-upx-version.outputs.version }}"
          LATEST_TAG="v$VERSION"
          # Detect Architecture
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then
            UPX_ARCH="amd64_linux"
          elif [ "$ARCH" = "aarch64" ]; then
            UPX_ARCH="arm64_linux"
          else
            echo "âŒ Unsupported architecture: $ARCH"
            exit 1
          fi
          echo "ðŸ’» Detected architecture: $ARCH -> $UPX_ARCH"
          # Download
          URL="https://github.com/upx/upx/releases/download/${LATEST_TAG}/upx-${VERSION}-${UPX_ARCH}.tar.xz"
          echo "â¬‡ï¸ Downloading from: $URL"
          curl -L "$URL" -o upx.tar.xz
          # Install to local bin
          mkdir -p ~/.local/bin
          echo "ðŸ“¦ Extracting..."
          tar -xf upx.tar.xz
          echo "ðŸ”§ Installing to ~/.local/bin..."
          mv upx-${VERSION}-${UPX_ARCH}/upx ~/.local/bin/
          chmod +x ~/.local/bin/upx
          # Cleanup
          rm -rf upx.tar.xz upx-${VERSION}-${UPX_ARCH}
      - name: ðŸ”§ Verify UPX
        run: |
           echo "$HOME/.local/bin" >> $GITHUB_PATH
           export PATH="$HOME/.local/bin:$PATH"
           upx --version
      - name: ðŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false
      - name: ðŸ’¾ Cache Terraform plugins
        uses: actions/cache@v5
        with:
          path: |
            iac/.terraform
            ~/.terraform.d/
          key: ${{ runner.os }}-${{ runner.arch }}-terraform-${{ hashFiles('**/iac/.terraform.lock.hcl', 'iac/main.tf', 'iac/providers.tf') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-terraform-
      - name: â˜ï¸ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}
          aws-region: ap-southeast-2
      - name: ðŸ” Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          allow-no-subscriptions: true
      - name: ðŸ’¾ Cache opencode
        id: cache-opencode
        uses: actions/cache@v5
        with:
          path: ~/.opencode
          key: ${{ runner.os }}-opencode
          restore-keys: |
            ${{ runner.os }}-opencode
      - name: ðŸ“¥ Install opencode
        if: steps.cache-opencode.outputs.cache-hit != 'true'
        run: curl -fsSL https://opencode.ai/install | bash
      - name: ðŸ”§ Add opencode to PATH
        run: echo "$HOME/.opencode/bin" >> $GITHUB_PATH
      - name: â¬†ï¸ Upgrade opencode
        run: opencode upgrade
      - name: ðŸš€ Fix Issue & Create PR
        run: |
          # Authenticate gh with installation token
          echo "${{ steps.generate_token.outputs.token }}" | gh auth login --with-token || true
          if [ "${{ github.event_name }}" = "issues" ]; then
            ISSUE_NUM=${{ github.event.issue.number }}
            ISSUE_TITLE="${{ github.event.issue.title }}"
            ISSUE_BODY="${{ github.event.issue.body }}"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ISSUE_NUM=${{ github.event.inputs.issue_number }}
            ISSUE_TITLE=$(gh issue view $ISSUE_NUM --json title -q .title)
            ISSUE_BODY=$(gh issue view $ISSUE_NUM --json body -q .body)
          else
            ISSUE_NUM=""
            ISSUE_TITLE="Workflow Failure: ${{ github.event.workflow_run.name }}"
            ISSUE_BODY="Fix workflow failure. Logs: ${{ github.event.workflow_run.html_url }}"
            # Use unique branch name for workflow failures to prevent collisions
            BRANCH_SUFFIX="workflow-failure-${{ github.event.workflow_run.id }}"
          fi
          BRANCH="fix/${BRANCH_SUFFIX:-issue-$ISSUE_NUM}"
          git checkout -B "$BRANCH"
          PROMPT="You are the best developer humanity has ever seen. Fix this issue completely:
          Issue: $ISSUE_TITLE
          Details: $ISSUE_BODY
          Environment:
          - Full Rust toolchain with cargo-lambda installed
          - Terraform CLI available
          - AWS CLI authenticated
          - Azure CLI authenticated
          - All build tools: upx, jq, make
           - Can run: make build, make test, cargo clippy, terraform validate
           Requirements:
           1. Analyze root cause with surgical precision
           2. Implement minimal, elegant fix following AGENTS.md standards
           3. Write comprehensive tests for new functionality
           4. Ensure all tests pass (make test)
           5. Verify code passes linting (use cargo clippy, not cargo check)
          6. Update documentation and comments
          7. Consider edge cases and error scenarios
          Note: DO NOT run make deploy - the PR workflow will automatically deploy to ephemeral environment for testing.
          Note: DO NOT modify any files in .github/workflows/ - workflow changes are not permitted.
          Write production-quality code with proper error handling, tests, and documentation."
           opencode run --agent build -m opencode/grok-code "$PROMPT" > fix_output.txt
           # Ensure code passes linting
           cargo clippy
           if git diff --quiet; then
            echo "No changes made"
            [ -n "$ISSUE_NUM" ] && gh issue comment $ISSUE_NUM --body "ðŸ¤– Analyzed but no code changes needed. See analysis:\n\n$(cat fix_output.txt)"
            exit 0
          fi
          git add -A
          # Remove workflow files from staging to avoid permission issues
          git reset HEAD .github/workflows/ 2>/dev/null || true
          if git diff --cached --quiet; then
            echo "No non-workflow changes to commit"
            [ -n "$ISSUE_NUM" ] && gh issue comment $ISSUE_NUM --body "ðŸ¤– Analysis complete. Changes were only to workflow files (not permitted). See analysis:\n\n$(cat fix_output.txt)"
            exit 0
          fi
          git commit -m "fix: resolve issue #${ISSUE_NUM:-workflow-failure}
          $(cat fix_output.txt | head -20)"
          git push -f -u origin "$BRANCH"
          PR_URL=$(gh pr create \
            --title "ðŸ¥· Fix: $ISSUE_TITLE" \
            --body "Fixes #${ISSUE_NUM}
          ## Changes
          $(cat fix_output.txt)
          ## Testing
          - Code follows AGENTS.md standards
          - Minimal changes for correctness
          - Ready for review
          ---
          ðŸ¤– Auto-generated by brown-ninja-bot" \
            --base main \
            --head "$BRANCH")
          # Add automerge label so the automerge workflow will pick this up
           PR_NUMBER=$(echo "$PR_URL" | awk -F'/' '{print $NF}')
           if [ "${{ github.event_name }}" = "workflow_run" ] && [ "${{ github.event.workflow_run.name }}" = "ðŸ¤– Auto-merge" ] && [ "${{ github.event.workflow_run.conclusion }}" = "failure" ]; then
             gh pr edit $PR_NUMBER --add-label automerge || true
           fi
           [ -n "$ISSUE_NUM" ] && gh issue comment $ISSUE_NUM --body "ðŸ¥· Fix implemented! PR: $PR_URL"
        env:
          OPENCODE_API_KEY: ${{ secrets.OPENCODE_API_KEY }}